<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>{{ label }} - Details</title>
  <style>
  :root { --island-bg: rgba(128,128,128,.9); --island-radius:1.5rem; --text:#fff; --accent:#1fb6b8; }
    body { margin:0; padding:5vh 5vw; color:var(--text); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif; background-image:url('/static/Images/background.gif'); background-size: cover; background-position:center; background-repeat:no-repeat; background-attachment:fixed; }
    .island { background:var(--island-bg); border-radius:var(--island-radius); padding:2rem; backdrop-filter: blur(4px); max-width: 1000px; margin:0 auto 2vh auto; }
    .btn, button, input[type="submit"], input[type="button"], a.btn { padding:.65rem 1.4rem; border:none; border-radius:.7rem; background: var(--accent); color:#fff; cursor:pointer; box-shadow: 0 4px 14px rgba(31,182,184,.25); text-decoration:none; transition: background-color .2s ease, filter .15s ease, box-shadow .2s ease; }
    .btn:hover, button:hover, input[type="submit"]:hover, input[type="button"]:hover, a.btn:hover { filter: brightness(0.92); box-shadow: 0 6px 18px rgba(31,182,184,.32); }
    .badge { font-size:.9rem; background:rgba(255,255,255,.2); padding:.2rem .6rem; border-radius:.4rem; display:inline-block; }
    .muted { opacity:.9; }
    h2, h3 { margin: 0 0 .6rem 0; }
    h2 { font-size:1.25rem; }
    h3 { font-size:1.05rem; margin-top:1.2rem; }
    .grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:1rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    table { width:100%; border-collapse:collapse; }
    th, td { text-align:left; padding:.45rem .4rem; border-bottom:1px solid rgba(255,255,255,.2); }
    th { font-weight:600; }
    .refs li { margin:.35rem 0; }
    .chip { display:inline-block; font-size:.85rem; padding:.1rem .5rem; border-radius:.4rem; background:rgba(255,255,255,.15); margin-right:.4rem; }
    .toc a { color:#fff; text-decoration:none; }
    .toc a:hover { text-decoration:underline; }
    .note { font-size:.95rem; opacity:.95; }
    code { background: rgba(255,255,255,.12); padding:.05rem .3rem; border-radius:.3rem; }
    .pill { display:inline-block; padding:.2rem .6rem; border-radius:999px; background:rgba(255,255,255,.18); margin-right:.35rem; font-size:.85rem;}
    ol.refs { list-style: none; margin: 0; padding-left: 0; }
  </style>
  <!-- MathJax for LaTeX-style math -->
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div class="island" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:2vh;">
    <div>
      <div style="font-size:1.6rem; font-weight:700;">{{ label }}</div>
      {% if kind %}<div class="badge" title="Kind">{{ kind }}</div>{% endif %}
      <div class="pill">Classical RSA</div><div class="pill">EUF-CMA (ROM)</div><div class="pill">Not PQ-resistant</div>
    </div>
    <div>
      <a href="/" class="btn">Back to home</a>
    </div>
  </div>

  <div class="island">
    <div style="font-weight:700; margin-bottom:.5rem;">About</div>
    <p class="muted">
      RSASSA-PSS (Probabilistic Signature Scheme) is the modern, provably secure RSA signature encoding defined in PKCS #1 v2.2 (RFC 8017) and profiled by NIST (FIPS 186-5). It replaces older deterministic encodings (RSASSA-PKCS1 v1.5) and achieves <em>existential unforgeability under adaptive chosen-message attack</em> (EUF-CMA) in the random-oracle model, assuming the RSA function is hard to invert.
    </p>
    <div class="toc muted">
      <span class="chip"><a href="#history">Origins & history</a></span>
      <span class="chip"><a href="#overview">Design overview</a></span>
      <span class="chip"><a href="#math">Mathematical setting</a></span>
      <span class="chip"><a href="#params">Parameter sets</a></span>
      <span class="chip"><a href="#algorithms">Algorithms</a></span>
      <span class="chip"><a href="#security">Security</a></span>
      <span class="chip"><a href="#impl">Implementation notes</a></span>
      <span class="chip"><a href="#proscons">Pros & cons</a></span>
      <span class="chip"><a href="#references">References</a></span>
    </div>
  </div>

  <div class="island" id="history">
    <h2>Origins & history</h2>
    <p class="muted">
      RSA (1977) provides a trapdoor permutation \(x\mapsto x^e \bmod n\). In 1996, Bellare and Rogaway proposed the <em>PSS</em> paradigm (“Exact Security of Digital Signatures”) giving tight ROM proofs for RSA signatures. PSS was adopted into PKCS #1 v2 (later v2.2 / RFC 8017), and NIST standardised its use within the Digital Signature Standard (FIPS 186-5). Today, RSA-PSS is the recommended RSA signature scheme in TLS, X.509, and many PKI profiles.
    </p>
  </div>

  <div class="island" id="overview">
    <h2>Design overview</h2>
    <p class="muted">
      PSS signs a hash of the message with a randomised <em>encoding</em> (EMSA-PSS) that mixes a per-signature salt via MGF1 into a Feistel-like structure. The encoded message <span class="mono">EM</span> is then turned into an integer and exponentiated with the private exponent \(d\). Verification recomputes the encoding from the message and checks it against the RSA “message representative” recovered with the public exponent \(e\).
    </p>
  </div>

  <div class="island" id="math">
    <h2>Mathematical setting</h2>
    <div class="muted">
      <h3>RSA keys</h3>
      <p>
        Generate primes \(p,q\), set \(n=pq\), choose \(e\) coprime to \(\lambda(n)=\mathrm{lcm}(p-1,q-1)\), and compute \(d\equiv e^{-1}\bmod \lambda(n)\).
        The signing and verification maps are:
      </p>
      <p class="mono">
        \( s \equiv \mathrm{EM}^d \bmod n,\qquad \hat{\mathrm{EM}} \equiv s^e \bmod n. \)
      </p>

      <h3>EMSA-PSS encoding</h3>
      <p>
        Let \(H\) be a hash (output length \(hLen\)), and MGF1 be the mask generator (typically based on \(H\)). Let \(k\) be the modulus length in bytes and \(\text{emBits}=\lfloor \log_2(n-1)\rfloor\), \(\text{emLen}=\lceil \text{emBits}/8\rceil\).
      </p>
      <ol>
        <li>Compute \(mHash = H(M)\). Choose a random salt of length \(sLen\).</li>
        <li>Form \( M' = \underbrace{0x00\ldots 0x00}_{8\ \text{octets}} \,\|\, mHash \,\|\, \text{salt} \).</li>
        <li>Compute \( H' = H(M') \).</li>
        <li>Let \( PS \) be zeros so that \( |DB| = \text{emLen} - hLen - 1 \). Set \( DB = PS \,\|\, 0x01 \,\|\, \text{salt} \).</li>
        <li>Compute \( dbMask = \mathrm{MGF1}(H', \text{emLen}-hLen-1) \) and \( \text{maskedDB} = DB \oplus dbMask \).</li>
        <li>Clear the leftmost \(8\cdot\text{emLen} - \text{emBits}\) bits of \(\text{maskedDB}[0]\).</li>
        <li>Output \( \mathrm{EM} = \text{maskedDB} \,\|\, H' \,\|\, 0xBC \).</li>
      </ol>
      <p class="note">Verification reverses these steps on \(\hat{\mathrm{EM}}\): check the trailer 0xBC, unmask DB with MGF1, confirm the leftmost bits are zeroed, recompute \(H'\) from \(M'\), and compare.</p>
    </div>
  </div>

  <div class="island" id="params">
    <h2>Parameter sets & sizes</h2>
    <div class="grid-2">
      <div class="muted">
        <h3>Recommended choices</h3>
        <ul>
          <li>Hash: SHA-256 (or SHA-384/512 for higher strength).</li>
          <li>MGF: MGF1 with the <em>same</em> hash as above.</li>
          <li>Salt length: \(sLen = hLen\) (typical PKI/TLS profiles); \(sLen=0\) is allowed but <em>not</em> recommended.</li>
          <li>Public exponent: \(e=65537\).</li>
        </ul>
      </div>
      <div class="muted">
        <h3>Key sizes (classical strength)</h3>
        <table>
          <thead><tr><th>Security ≈</th><th>Modulus</th><th>Hash</th></tr></thead>
          <tbody>
            <tr><td>~112-bit</td><td>RSA-2048</td><td>SHA-224/256</td></tr>
            <tr><td>~128-bit</td><td>RSA-3072</td><td>SHA-256/384</td></tr>
            <tr><td>~192-bit</td><td>RSA-7680</td><td>SHA-384/512</td></tr>
            <tr><td>~256-bit</td><td>RSA-15360</td><td>SHA-512</td></tr>
          </tbody>
        </table>
        <p class="note">Mapping per NIST SP 800-57 Pt.1; choose hash output ≥ desired security strength.</p>
      </div>
    </div>
    <p class="muted">Signature size equals the modulus length (e.g., 256 B for RSA-2048).</p>
  </div>

  <div class="island" id="algorithms">
    <h2>Algorithms</h2>

    <h3>Key generation</h3>
    <p class="muted">
      Generate \(p,q\) (with primality/self-tests), compute \(n, \lambda(n), e, d\). Store CRT values \(d_p, d_q, q^{-1}\bmod p\) for fast signing.
    </p>

    <h3>Signing (RSASSA-PSS)</h3>
    <ol class="muted">
      <li>Compute \(mHash = H(M)\). Sample random \(\text{salt}\in\{0,1\}^{8\,sLen}\).</li>
      <li>Build \( \mathrm{EM} \leftarrow \mathrm{EMSA\mbox{-}PSS\mbox{-}ENCODE}(mHash, \text{emBits}, sLen) \).</li>
      <li>Output signature \( s \equiv \mathrm{EM}^d \bmod n \) (use CRT and RSA blinding).</li>
    </ol>

    <h3>Verification</h3>
    <ol class="muted">
      <li>Compute \( mHash = H(M) \) and recover \( \hat{\mathrm{EM}} \equiv s^e \bmod n \).</li>
      <li>Check \( \mathrm{EMSA\mbox{-}PSS\mbox{-}VERIFY}(mHash, \hat{\mathrm{EM}}, \text{emBits}, sLen) \) including trailer 0xBC and leading-bit clear.</li>
      <li>Accept iff all checks pass.</li>
    </ol>
  </div>

  <div class="island" id="security">
    <h2>Security at a glance</h2>
    <ul class="muted">
      <li><b>Goal:</b> EUF-CMA in the Random-Oracle Model (ROM).</li>
      <li><b>Assumption:</b> RSA inversion is hard; \(H\) and MGF1 behave as random oracles.</li>
      <li><b>Proofs:</b> PSS achieves tight security bounds (exact security) relative to RSA; PKCS #1 fixes domain separation and bit-clearing (emBits) details.</li>
      <li><b>Comparison:</b> Prefer PSS over PKCS#1 v1.5 signatures for new designs; PSS is robust against classic forgeries applicable to v1.5 encodings.</li>
      <li><b>Quantum note:</b> RSA (including PSS) is broken by Shor’s algorithm → plan for PQ migration or hybrid deployments.</li>
    </ul>
  </div>

  <div class="island" id="impl">
    <h2>Implementation notes</h2>
    <ul class="muted">
      <li>Use vetted libraries; fix \(H\), MGF1, and \(sLen\) per key (don’t mix).</li>
      <li>Strong RNG for salts; <em>never</em> reuse salt deterministically across signatures.</li>
      <li>Enable CRT with <em>verification step</em> (re-encrypt signature with \(e\)) to catch faults; use RSA blinding to mitigate timing/leakage.</li>
      <li>Constant-time parsing and masking in EMSA-PSS; uniform error handling on verification.</li>
      <li>Keys: validate modulus structure, ensure minimum prime sizes and protections against small-exponent/low-entropy pitfalls.</li>
    </ul>
  </div>

  <div class="island" id="proscons">
    <h2>Pros & cons</h2>
    <div class="grid-2">
      <div>
        <h3>Pros</h3>
        <ul class="muted">
          <li>Provably secure (ROM), widely standardised (RFC 8017, FIPS 186-5).</li>
          <li>Interoperable and well-supported in TLS, X.509, JOSE, SSH, etc.</li>
          <li>Flexible: hashes and salt lengths tune performance/security.</li>
        </ul>
      </div>
      <div>
        <h3>Cons</h3>
        <ul class="muted">
          <li>Large keys and slower private operations vs. modern lattice signatures.</li>
          <li>Requires high-quality randomness for salts; RNG failures can be catastrophic.</li>
          <li>No post-quantum security.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="island" id="references">
    <h2>References</h2>
    <ol class="refs muted">
      <li>[1] K. Moriarty, B. Kaliski, J. Jonsson, and A. Rusch, “<i>PKCS #1: RSA Cryptography Specifications Version 2.2</i>,” RFC 8017, Nov. 2016.</li>
      <li>[2] M. Bellare and P. Rogaway, “The Exact Security of Digital Signatures: How to Sign with RSA and Rabin,” in <i>EUROCRYPT ’96</i>, LNCS 1070, 1996.</li>
      <li>[3] E. Barker, J. Kelsey, et al., “<i>FIPS 186-5: Digital Signature Standard (DSS)</i>,” NIST, Feb. 2023.</li>
      <li>[4] E. Barker, “<i>SP 800-57 Part 1 Rev. 5: Recommendation for Key Management</i>,” NIST, May 2020.</li>
      <li>[5] D. Boneh, R. A. DeMillo, and R. J. Lipton, “On the Importance of Eliminating Errors in Cryptographic Computations,” <i>J. Cryptology</i>, 2001 (Eurocrypt ’97).</li>
      <li>[6] P. Kocher, “Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Others,” in <i>CRYPTO ’96</i>, 1996.</li>
      <li>[7] A. Lenstra and E. Verheul, “Selecting Cryptographic Key Sizes,” <i>J. of Cryptology</i>, 2001 (context for historical sizing).</li>
      <li>[8] ANSI X9.31 / X9.62 and later PKI profiles (TLS/X.509) adopting RSA-PSS, various years.</li>
    </ol>
  </div>
</body>
</html>
